package crypto

import (
	"crypto/rand"
	"fmt"
	"math/big"
)

var (
	// For now, hard-coded. Generated by nil-generator (cmd/generator/main.go).
	p = big.NewInt(3962429869)
	g = big.NewInt(15)
	h = big.NewInt(16)
	q = big.NewInt(330202489)
)

func Load(paramsFile string) (*Params, error) {

}

func GenerateC() (*big.Int, error) {
	return RandomInt(8)
}

func GenerateR1AndR2() (*big.Int, *big.Int, *big.Int, error) {
	// Generate k.
	k, err := rand.Prime(rand.Reader, 256)
	if err != nil {
		return nil, nil, nil, fmt.Errorf("Failed to generate k: %w", err)
	}

	// Generate r1: g^k mod p
	r1 := new(big.Int).Exp(g, k, p)

	// Generate r2: h^k mod p
	r2 := new(big.Int).Exp(h, k, p)

	return r1, r2, k, nil
}

func GenerateS(x, k, c *big.Int) (*big.Int, error) {
	s := new(big.Int)
	s.Mul(c, x)
	s.Sub(k, s)
	s.Mod(s, q)

	return s, nil
}

func GenerateY1AndY2(x *big.Int) (*big.Int, *big.Int, error) {
	// Generate y1: g^x mod p
	y1 := new(big.Int).Exp(g, x, p)

	// Generate y2: h^x mod p
	y2 := new(big.Int).Exp(h, x, p)

	return y1, y2, nil
}

func RandomInt(bits int) (*big.Int, error) {
	buffer := make([]byte, bits/8)
	_, err := rand.Read(buffer)
	if err != nil {
		return nil, fmt.Errorf("Failed to read random number into buffer: %w", err)
	}

	return new(big.Int).SetBytes(buffer), nil
}

func VerifyR1AndR2(r1, r2, s, c, y1, y2 *big.Int) bool {
	// Compute g^s * y1^c.
	term1 := new(big.Int).Exp(g, s, p)
	term2 := new(big.Int).Exp(y1, c, p)
	r1Cmp := new(big.Int).Mul(term1, term2)
	r1Cmp.Mod(r1Cmp, p)

	// Compute h^s * y2^c.
	term1 = new(big.Int).Exp(h, s, p)
	term2 = new(big.Int).Exp(y2, c, p)
	r2Cmp := new(big.Int).Mul(term1, term2)
	r2Cmp.Mod(r2Cmp, p)

	// Compare them against r1 and r2, respectively.
	return r1.Cmp(r1Cmp) == 0 && r2.Cmp(r2Cmp) == 0
}
